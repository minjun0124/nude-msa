# CloudNative

클라우드 네이티브 기술을 통해 조직은 퍼블릭, 프라이빗 및 하이브리드 클라우드와 같은 최신 동적 환경에서 확장 가능한 애플리케이션을 빌드하고 실행할 수 있습니다. 컨테이너, 서비스 메시, 마이크로 서비스, 변경 불가능한 인프라 및 선언적 API는 이 접근 방식을 예로 들 수 있습니다.</br>

이러한 기술을 사용하면 복원력 있고 관리 가능하며 관찰 가능한 느슨하게 결합된 시스템을 사용할 수 있습니다. 강력한 자동화와 결합하면 엔지니어가 최소한의 수고로 자주 예측 가능하도록 큰 영향을 미치는 변경을 할 수 있습니다. </br>

[<div style="text-align: right"> - Cloud Native Computing Foundation -</div>](https://github.com/cncf/foundation/blob/master/charter.md)

<br>

Cloud Native를 위한 주요 4가지 요소
---

**1. DevOps**<br>
- 애플리케이션 개발-운영 간의 협업 프로세스를 자동화
- 애플리케이션의 개발과 개선 속도 향상

**2. CI/CD**<br>
- 지속적인 통합(Continous Intergration) : 개발자가 작업한 코드를 자동으로 테스트하고 테스트에 통과하면 코드를 통합하여 저장
- 지속적인 배포(Continuos Deployment) : 작업한 코드 및 변경사항들은 테스트를 거쳐 리포지토리에 업로드되고 실 서비스 배포로 릴리즈까지 자동화

**3. 컨테이너 기반 인프라**<br>
- 가상화 기술 중 하나
- 시스템을 가상화하는 것이 아니라 애플리케이션을 구동할 수 있는 컴퓨팅 작업을 패키징하여 가상화한 것

**4. Microservice**<br>
- 애플리케이션을 구성하는 서비스들을 독립적인 작은 단위로 분해하여 구축
- 각 구성 요소들을 네트워크로 통신하는 아키텍처로 서비스 안정성과 확장성(scaling)을 지원


<br>

12 Factor App
---

**1. Code Base**
- 코드와 app 사이에는 1:1 관계가 성립해야함, 1개의 코드베이스에서 여러개의 앱(서비스)을 배포해선 안된다.
- SVN, GIT과 같은 VCM을 이용하여 코드 관리
- 마이크로서비스마다 코드베이스를 가짐, 다른 마이크로서비스와 공유되지 않음
- 공유가 필요한 코드는 라이브러리화해서 공유
<br>

**2. Dependencies**
- app의 의존관계는 명시적으로 선언되어야 함 (maven인 경우 pom.xml, gradle인 경우 build.gradle, node인 경우 npm)
- 모든 라이브러리는 central - maven repository, nexus 와 같은 라이브러리 저장소에서 내려받을수 있어야함
<br>

**3. Config**
- 설정정보는 app 코드에 저장하지 않고, 환경설정파일로 분리해서 사용해야 함
- 로컬,개발,운영환경별 설정파일로 분리하여 사용하는것이 좋음
- MSA에서는 설정정보를 외부중앙서버에서 별도로 관리
<br>

**4. Backing Service**
- app에서 네트워크로 접근하여 이용하는 모든서비스를 연결된 리소스
- rest api, db, cache, smtp, mq 등
<br>

**5. Build, Release, Run**
- 코드베이스는 3단계를 거쳐 배포로 변환된다.

    빌드 : 라이브러리와 소스를 내려받아 컴파일하여 하나의 패키지를 만듬 (예 : jar, war 파일 생성) <br>
    릴리스 : 빌드된 패키지에 환경설정 정보를 조합 (예 : dockerfile을 이용하여 이미지 생성, 버전별로 기록되어 롤백가능)<br>
    실행 : 릴리스에서 만들어진 결과물을 실행환경에서 애플리케이션을 실행 (예 : dockerimages를 내려받아서 컨테이너로 실행)<br>
<br>

**6. Process**
- 애플리케이션을 하나 혹은 여러개의 무상태(stateless) 프로세스로 실행 (수평확장, 무상태)
- 무상태 장점 : 수평확장하기에 용이하기 때문에 장애 대응성이 좋아짐 
- 상태유지가 필요한 데이터는 DB나 인메모리캐쉬같은 백엔드서비스를 이용하여 처리함
<br>

**7. Port Binding**
- 각 마이크로 서비스는 자체 포트에 노출되는 인터페이스 및 기능으로 자체 포함
- 다른 마이크로 서비스로부터 격리
<br>

**8. Concurrency**
- 수직확장이 아니라 수평확장을 통한 동시성을 말함(프로세스 복제, 동일서버증설)
- webapp 계층을 무상태계층으로 개발하면 상태를 가지지 않으므로 수평확장/축소를 자유롭게 할수 있음. (예 : jwt 인증)
<br>

**9. Disposability**
- 중지될때 진행중이던 프로세스는 모두 완료되어야 함 (graceful shutdown 지원)
- 가능한 빠른시간내에 시작/종료되어야 함 (마이크로서비스를 작은 규모로 유지)
- Docker 컨테이너는 기본적으로이 요구 사항을 충족
<br>

**10. Dev/Prod Parity**
- 배포환경의 차이는 크게 3가지
    - 시간의 차이 (배포 간의 간격 : 몇 주 vs 몇 시간)
    - 담당자의 차이 (코드 작성자와 코드 배포자 : 다른사람 vs 같은사람)
    - 툴의 차이 (개발 환경과 production 환경 : 불일치 vs 최대한 유사함)

    => 개발환경과 배포환경을 최대한 동일하게 유지하는것을 중요하게 생각함
<br>

**11. Logs**
- 로그는 모든 실행중인 프로세스와 서비스의 아웃풋 스트림으로부터 수정된 이벤트가 시간순으로 정렬된 스트림
- 애플리케이션은 아웃풋 스트림의 전달이나 저장에 절대 관여하지 않는다.
- 이벤트 집계를 사용하여 처리하고 데이터를 Monitoring 서비스에 전파하여 장기보관
<br>

**12. Admin Process**
- 어드민 또는 유지보수 작업을 일회성 프로세스(데이터베이스 마이그레이션, 일회성 스크립트 실행 등)로 실행해야 한다.<br>

<br>
